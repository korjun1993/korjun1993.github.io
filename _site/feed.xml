<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-11-10T00:33:32+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">쿠키의 개발 블로그</title><subtitle>korjun1993의 개인 블로그</subtitle><author><name>호준</name></author><entry><title type="html">Lucene 공식문서 읽기</title><link href="http://localhost:4000/2024/01/17/lucene/" rel="alternate" type="text/html" title="Lucene 공식문서 읽기" /><published>2024-01-17T00:00:00+09:00</published><updated>2024-01-17T00:00:00+09:00</updated><id>http://localhost:4000/2024/01/17/lucene</id><content type="html" xml:base="http://localhost:4000/2024/01/17/lucene/">&lt;h3 id=&quot;index-file-formats&quot;&gt;Index File Formats&lt;/h3&gt;

&lt;p&gt;Lucene의 주요 개념은 다음 세 가지이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Index: Document의 집합&lt;/li&gt;
  &lt;li&gt;Document: Field의 집합&lt;/li&gt;
  &lt;li&gt;Field: 이름이 명명된 Term의 집합, Term: 문자열&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Field, Term에 대한 정의가 조금
헷갈려서, &lt;a href=&quot;https://stackoverflow.com/questions/63976680/lucene-difference-between-term-and-fields&quot;&gt;스택오버플로우의 어떤 글&lt;/a&gt;을 읽어봤다.
관계형 데이터베이스에 비유하면, Field는 컬럼, Term은 컬럼에 해당하는
값이다. &lt;a href=&quot;https://lucene.apache.org/core/8_6_2/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#Terms&quot;&gt;Lucene 공식문서의 classic query parser 파트&lt;/a&gt;
에서는 아래와 같은 예시를 통해 이해를 도와주고 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;title: &quot;The Right Way&quot;
text: &quot;go&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 인덱스는 두 개의 필드를 포함하고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;title&lt;/li&gt;
  &lt;li&gt;text&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;역색인inverted-indexing&quot;&gt;역색인(Inverted Indexing)&lt;/h3&gt;

&lt;p&gt;효율적인 term 기반의 검색을 위해 인덱스는 term의 통계 정보를 저장한다.
Lucene의 인덱스는 역인덱스라고 알려진 인덱스 계열에 속한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;안녕하세요 Elasticsearch를 이용해서 개발하고 있는 검색 개발자입니다.
Elasticsearch를 배우고 싶은 쥬니어 개발자입니다.
쥬니어 개발자는 검색 개발시 Elasticsearch를 이용하면 좋나요?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/lucene/inverted_index.png&quot; width=&quot;700&quot; alt=&quot;inverted_index&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Elasticsearch”라는 term이 등장한 문서를 찾는다고 생각해보자. 연인덱스 구조를 하고 있는 위 표에서 아주 쉽고 빠르게 찾을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;세그먼트segments&quot;&gt;세그먼트(Segments)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/lucene/lucene_segment.png&quot; width=&quot;700&quot; alt=&quot;segments&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lucene의 인덱스는 여러개의 세그먼트로 구성됩니다.
세그먼트 안에는 수많은 도큐먼트가 저장됩니다.
세그먼트는 다른 세그먼트와 별개로 완전히 독립적으로 동작하며, 별도로 검색할 수 있습니다.
인덱스를 변화시키는 방법은 두 가지가 존재합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;새로운 문서를 위한 세그먼트 만들기&lt;/li&gt;
  &lt;li&gt;이미 존재하는 세그먼트를 병합하기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;세그먼트는 불변(Immutable) 특성을 지니고 있는데요. 다시 말하면 수정이 불가능하고, 읽기만 가능합니다.
이러한 특성으로 인해 멀티 스레드 환경에서 thread-safe 합니다.
세그먼트를 여러 스레드에서 공유해서 사용해도, 다른 스레드에 의해 변경되지 않을 것이기 때문에 언제나 그 결과가 예측 가능한 것이죠.&lt;/p&gt;

&lt;h3 id=&quot;색인&quot;&gt;색인&lt;/h3&gt;

&lt;p&gt;IndexWriter가 Index File들을 생성하는 과정을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/lucene/index_writer.png&quot; width=&quot;600&quot; alt=&quot;index_writer&quot; /&gt;
출처: https://www.alibabacloud.com/blog/lucene-indexwriter-an-in-depth-introduction_594673&lt;/p&gt;

&lt;p&gt;하나의 IndexWriter는 스레드별로 동작하는 DocumentsWriterPerThread들에게 세그먼트 파일 생성 작업을 위임하고, 해당 작업은 병렬로 수행됩니다.&lt;/p&gt;

&lt;p&gt;출처: https://lucene.apache.org/core/3_0_3/fileformats.html#Index%20File%20Formats&lt;/p&gt;</content><author><name>호준</name></author><category term="Lucene" /><summary type="html">Index File Formats</summary></entry></feed>